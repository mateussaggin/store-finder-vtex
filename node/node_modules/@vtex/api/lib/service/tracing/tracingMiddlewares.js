"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const opentracing_1 = require("opentracing");
const constants_1 = require("../../constants");
const tracing_1 = require("../../tracing");
const Tags_1 = require("../../tracing/Tags");
const spanSetup_1 = require("./spanSetup");
const PATHS_BLACKLISTED_FOR_TRACING = ['/metrics', '/_status', '/healthcheck'];
exports.addTracingMiddleware = (tracer) => {
    return async function addTracing(ctx, next) {
        if (PATHS_BLACKLISTED_FOR_TRACING.includes(ctx.request.path)) {
            return next();
        }
        const rootSpan = tracer.extract(opentracing_1.FORMAT_HTTP_HEADERS, ctx.request.headers);
        const currentSpan = tracer.startSpan('unknown-operation', {
            childOf: rootSpan,
            tags: {
                [Tags_1.Tags.SPAN_KIND]: Tags_1.Tags.SPAN_KIND_RPC_SERVER,
                [Tags_1.Tags.HTTP_URL]: ctx.request.originalUrl,
                [Tags_1.Tags.HTTP_METHOD]: ctx.request.method,
                [Tags_1.Tags.HTTP_PATH]: ctx.request.path,
                [Tags_1.Tags.VTEX_REQUEST_ID]: ctx.get(constants_1.REQUEST_ID_HEADER),
                [Tags_1.Tags.VTEX_WORKSPACE]: ctx.get(constants_1.WORKSPACE_HEADER),
                [Tags_1.Tags.VTEX_ACCOUNT]: ctx.get(constants_1.ACCOUNT_HEADER),
            },
        });
        ctx.tracing = { currentSpan, tracer };
        try {
            await next();
        }
        catch (err) {
            spanSetup_1.injectErrorOnSpan(currentSpan, err);
            throw err;
        }
        finally {
            currentSpan.setTag(Tags_1.Tags.HTTP_STATUS_CODE, ctx.response.status);
            currentSpan.finish();
            const traceInfo = tracing_1.getTraceInfo(currentSpan);
            if (traceInfo.isSampled) {
                ctx.set(constants_1.TRACE_ID_HEADER, traceInfo.traceId);
            }
        }
    };
};
exports.nameSpanOperationMiddleware = (operationType, operationName) => {
    return function nameSpanOperation(ctx, next) {
        var _a;
        (_a = ctx.tracing) === null || _a === void 0 ? void 0 : _a.currentSpan.setOperationName(`${operationType}:${operationName}`);
        return next();
    };
};
exports.traceUserLandRemainingPipelineMiddleware = (spanName, tags = {}) => {
    return async function traceUserLandRemainingPipeline(ctx, next) {
        const tracingCtx = ctx.tracing;
        ctx.tracing = undefined;
        const span = tracingCtx.tracer.startSpan(spanName, { childOf: tracingCtx.currentSpan, tags });
        const userLandTracer = ctx.vtex.tracer;
        userLandTracer.setFallbackSpan(span);
        userLandTracer.lockFallbackSpan();
        try {
            await next();
        }
        catch (err) {
            spanSetup_1.injectErrorOnSpan(span, err);
            throw err;
        }
        finally {
            ctx.tracing = tracingCtx;
            span.finish();
        }
    };
};
