"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const buildFullPath_1 = __importDefault(require("axios/lib/core/buildFullPath"));
const constants_1 = require("../../../../../../constants");
const Tags_1 = require("../../../../../../tracing/Tags");
exports.injectRequestInfoOnSpan = (span, http, config) => {
    let fullUrl = null;
    const spanContext = span.context();
    if (spanContext.isSampled == null || spanContext.isSampled()) {
        fullUrl = buildFullPath_1.default(config.baseURL, http.getUri(config));
    }
    span.addTags({
        [Tags_1.Tags.SPAN_KIND]: Tags_1.Tags.SPAN_KIND_RPC_CLIENT,
        [Tags_1.Tags.HTTP_METHOD]: config.method,
        [Tags_1.Tags.HTTP_URL]: fullUrl,
        [Tags_1.Tags.HTTP_RETRY_COUNT]: config.retryCount || 0,
    });
    span.log({ event: 'request-headers', headers: config.headers });
};
// Response may be undefined in case of client timeout, invalid URL, ...
exports.injectResponseInfoOnSpan = (span, response) => {
    if (!response) {
        span.setTag(Tags_1.Tags.HTTP_NO_RESPONSE, 'true');
        return;
    }
    span.log({ event: 'response-headers', headers: response.headers });
    span.setTag(Tags_1.Tags.HTTP_STATUS_CODE, response.status);
    if (response.headers[constants_1.ROUTER_CACHE_HEADER]) {
        span.setTag(Tags_1.Tags.HTTP_ROUTER_CACHE, response.headers[constants_1.ROUTER_CACHE_HEADER]);
    }
};
