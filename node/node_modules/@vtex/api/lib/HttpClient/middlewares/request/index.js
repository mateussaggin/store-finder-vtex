"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const qs_1 = require("qs");
const ramda_1 = require("ramda");
const renameBy_1 = require("../../../utils/renameBy");
const setupAxios_1 = require("./setupAxios");
const http = setupAxios_1.getConfiguredAxios();
const paramsSerializer = (params) => {
    return qs_1.stringify(params, { arrayFormat: 'repeat' });
};
exports.defaultsMiddleware = ({ baseURL, rawHeaders, params, timeout, retries, verbose, exponentialTimeoutCoefficient, initialBackoffDelay, exponentialBackoffCoefficient, httpsAgent }) => {
    const countByMetric = {};
    const headers = renameBy_1.renameBy(ramda_1.toLower, rawHeaders);
    return async (ctx, next) => {
        ctx.config = {
            baseURL,
            exponentialBackoffCoefficient,
            exponentialTimeoutCoefficient,
            httpsAgent: ctx.config.httpsAgent || httpsAgent,
            initialBackoffDelay,
            maxRedirects: 0,
            retries,
            timeout,
            validateStatus: status => (status >= 200 && status < 300),
            verbose,
            ...ctx.config,
            headers: {
                ...headers,
                ...renameBy_1.renameBy(ramda_1.toLower, ctx.config.headers),
            },
            params: {
                ...params,
                ...ctx.config.params,
            },
            paramsSerializer,
            retryCount: 0,
        };
        if (ctx.config.verbose && ctx.config.metric) {
            const current = countByMetric[ctx.config.metric];
            countByMetric[ctx.config.metric] = (current || 0) + 1;
            ctx.config.count = countByMetric[ctx.config.metric];
            ctx.config.label = `${ctx.config.metric}#${ctx.config.count}`;
        }
        await next();
    };
};
const ROUTER_CACHE_KEY = 'x-router-cache';
const ROUTER_CACHE_HIT = 'HIT';
const ROUTER_CACHE_REVALIDATED = 'REVALIDATED';
const ROUTER_CACHE_KEY_PATH = ['response', 'headers', ROUTER_CACHE_KEY];
const ROUTER_RESPONSE_STATUS_PATH = ['response', 'status'];
exports.routerCacheMiddleware = async (ctx, next) => {
    await next();
    const routerCacheHit = ramda_1.path(ROUTER_CACHE_KEY_PATH, ctx);
    const status = ramda_1.path(ROUTER_RESPONSE_STATUS_PATH, ctx);
    if (routerCacheHit === ROUTER_CACHE_HIT || (routerCacheHit === ROUTER_CACHE_REVALIDATED && status !== 304)) {
        ctx.cacheHit = {
            memory: 0,
            revalidated: 0,
            ...ctx.cacheHit,
            router: 1,
        };
    }
};
exports.requestMiddleware = (limit) => async (ctx, next) => {
    const makeRequest = () => http.request(ctx.config);
    ctx.response = await (limit ? limit(makeRequest) : makeRequest());
};
